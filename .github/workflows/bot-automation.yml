name: Bot Automation
on:
  push:
    branches: ["main"]
  workflow_dispatch:
    inputs:
      test_issue:
        description: "Create and close a test issue to verify write access"
        required: false
        default: "true"
      pages_enable:
        description: "Attempt to enable GitHub Pages via API (if supported)"
        required: false
        default: "true"
      assignee:
        description: "Assignee username for test issue (optional)"
        required: false
        default: ""
      close_issue:
        description: "Auto-close the test issue after successful verification"
        required: false
        default: "false"
jobs:
  verify_bot_token:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Validate BOT_TOKEN presence
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
        run: |
          if [ -z "${BOT_TOKEN}" ]; then
            echo "BOT_TOKEN is missing in repository secrets"
            exit 1
          fi
          echo "BOT_TOKEN is present (value masked by Actions)"
      - name: Token format check
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
        run: |
          LEN=${#BOT_TOKEN}
          if [ $LEN -lt 40 ]; then
            echo "ERROR CODE=FMT001 MSG=Token length too short ($LEN)"
            exit 1
          fi
          PREFIX=${BOT_TOKEN:0:10}
          case "$PREFIX" in
            ghp_*|gho_*|ghs_*|ghu_*)
              echo "Detected classic PAT prefix"
              ;;
            github_pat*)
              echo "Detected fine-grained PAT prefix"
              ;;
            *)
              echo "WARNING CODE=FMT002 MSG=Unknown token prefix; proceeding to API validation"
              ;;
          esac
      - name: Auth check and repo details (with permissions/headers)
        uses: actions/github-script@v7
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
        with:
          script: |
            const token = process.env.BOT_TOKEN;
            function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
            async function callWithRetry(fn, desc, max=3){
              let attempt=0;
              while(true){
                try{ attempt++; const res = await fn(); return res; }
                catch(err){
                  const status = err.status || 'N/A';
                  const msg = err.message || String(err);
                  const rl = err.response?.headers?.['x-ratelimit-remaining'];
                  const ra = err.response?.headers?.['retry-after'];
                  core.warning(`STEP=${desc} ATTEMPT=${attempt} STATUS=${status} MSG=${msg}`);
                  if (status==403 && rl==='0' && attempt<max){
                    const wait = (ra? Number(ra)*1000 : 5000);
                    core.notice(`Rate limited; retrying after ${wait}ms`);
                    await sleep(wait); continue;
                  }
                  throw err;
                }
              }
            }
            const octo = github.getOctokit(token);
            try{
              const userRes = await callWithRetry(()=>octo.request('GET /user'), 'get-user');
              core.notice(`Authenticated as ${userRes.data.login}`);
              const scopes = userRes.headers['x-oauth-scopes'] || 'unknown';
              const expiration = userRes.headers['x-oauth-token-expiration'] || 'unknown';
              core.notice(`Token scopes: ${scopes}`);
              core.notice(`Token expiration: ${expiration}`);
            } catch(err){
              const status = err.status || 'N/A';
              core.error(`AUTH CODE=AUTH401 STATUS=${status} MSG=${err.message}`);
              core.setFailed('Token authentication failed');
              return;
            }
            const { owner, repo } = context.repo;
            try{
              const repoInfo = await callWithRetry(()=>octo.rest.repos.get({ owner, repo }), 'repos-get');
              core.notice(`Repo: ${repoInfo.data.full_name} (private=${repoInfo.data.private})`);
            } catch(err){
              core.error(`PERM CODE=PERM403 STATUS=${err.status} MSG=${err.message}`);
              core.setFailed('Token lacks required repository permissions');
              return;
            }
      - name: GitHub Pages status and enable if possible
        if: ${{ github.event.inputs.pages_enable != 'false' }}
        uses: actions/github-script@v7
        continue-on-error: true
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
        with:
          script: |
            const token = process.env.BOT_TOKEN;
            const octo = github.getOctokit(token);
            const { owner, repo } = context.repo;
            try {
              const res = await octo.rest.repos.getPages({ owner, repo });
              core.notice(`Pages status: ${res.status} (enabled)`);
              core.notice(`Pages build type: ${res.data.build_type || 'unknown'}`);
            } catch (err) {
              core.warning(`GetPages failed: ${err.status} ${err.message}`);
              try {
                // Attempt legacy Pages creation (may not be supported on all repos)
                const createRes = await octo.request('POST /repos/{owner}/{repo}/pages', {
                  owner, repo, source: { branch: 'main', path: '/' }
                });
                core.notice(`Attempted Pages creation: ${createRes.status}`);
              } catch (createErr) {
                core.warning(`Pages creation not supported or failed: ${createErr.status} ${createErr.message}`);
                core.notice('If Pages uses GitHub Actions, enable it via Settings → Pages → Source: GitHub Actions.');
              }
            }
      - name: Create and verify test issue
        if: ${{ github.event.inputs.test_issue != 'false' }}
        uses: actions/github-script@v7
        id: create_verify
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
        with:
          script: |
            const token = process.env.BOT_TOKEN;
            const octo = github.getOctokit(token);
            const { owner, repo } = context.repo;
            function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
            async function callWithRetry(fn, desc, max=3){
              let attempt=0;
              while(true){
                try{ attempt++; const res = await fn(); return res; }
                catch(err){
                  const status = err.status || 'N/A';
                  const msg = err.message || String(err);
                  const rl = err.response?.headers?.['x-ratelimit-remaining'];
                  const ra = err.response?.headers?.['retry-after'];
                  core.warning(`STEP=${desc} ATTEMPT=${attempt} STATUS=${status} MSG=${msg}`);
                  if (status==403 && rl==='0' && attempt<max){
                    const wait = (ra? Number(ra)*1000 : 5000);
                    core.notice(`Rate limited; retrying after ${wait}ms`);
                    await sleep(wait); continue;
                  }
                  throw err;
                }
              }
            }
            const labelNames = ['automation','verification'];
            const title = `Automation verification ${new Date().toISOString()}`;
            const assigneeInput = core.getInput('assignee');
            const body = [
              'Created by bot-automation workflow.',
              'Validation steps:',
              '- Token format and API scopes checked',
              '- Repository permissions checked',
              '- Rate limit handling enabled'
            ].join('\n');
            let issue;
            try{
              issue = await callWithRetry(()=>octo.rest.issues.create({
                owner, repo, title, body,
                assignees: assigneeInput ? [assigneeInput] : undefined,
                labels: labelNames
              }), 'issues-create');
              core.notice(`Issue created: #${issue.data.number}`);
              core.setOutput('issue_number', String(issue.data.number));
            } catch(err){
              core.error(`ISSUE CODE=ISSUE500 STATUS=${err.status} MSG=${err.message}`);
              core.setFailed('Failed to create test issue');
              core.setOutput('verify_status','failed');
              return;
            }
            try{
              const got = await callWithRetry(()=>octo.rest.issues.get({
                owner, repo, issue_number: issue.data.number
              }), 'issues-get');
              core.notice(`Issue retrieved: #${got.data.number} state=${got.data.state} labels=${got.data.labels.map(l=>l.name).join(',')}`);
              core.setOutput('verify_status','ok');
            } catch(err){
              core.error(`VERIFY CODE=VERIFY404 STATUS=${err.status} MSG=${err.message}`);
              core.setFailed('Failed to verify test issue');
              core.setOutput('verify_status','failed');
              return;
            }
      - name: Conditional close issue
        if: ${{ github.event.inputs.close_issue == 'true' && steps.create_verify.outputs.verify_status == 'ok' }}
        uses: actions/github-script@v7
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
        with:
          script: |
            const token = process.env.BOT_TOKEN;
            const octo = github.getOctokit(token);
            const { owner, repo } = context.repo;
            const issue_number = Number('${{ steps.create_verify.outputs.issue_number }}');
            if (!issue_number || Number.isNaN(issue_number)){
              core.setFailed('No valid issue_number from previous step');
              return;
            }
            function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
            async function callWithRetry(fn, desc, max=3){
              let attempt=0;
              while(true){
                try{ attempt++; const res = await fn(); return res; }
                catch(err){
                  const status = err.status || 'N/A';
                  const msg = err.message || String(err);
                  const rl = err.response?.headers?.['x-ratelimit-remaining'];
                  const ra = err.response?.headers?.['retry-after'];
                  core.warning(`STEP=${desc} ATTEMPT=${attempt} STATUS=${status} MSG=${msg}`);
                  if (status==403 && rl==='0' && attempt<max){
                    const wait = (ra? Number(ra)*1000 : 5000);
                    core.notice(`Rate limited; retrying after ${wait}ms`);
                    await sleep(wait); continue;
                  }
                  throw err;
                }
              }
            }
            const got = await callWithRetry(()=>octo.rest.issues.get({ owner, repo, issue_number }), 'issues-get-before-close');
            if (got.data.state !== 'open'){
              core.notice(`Issue #${issue_number} is not open; state=${got.data.state}. Skipping closure.`);
              return;
            }
            await callWithRetry(()=>octo.rest.issues.update({ owner, repo, issue_number, state: 'closed' }), 'issues-close');
            core.notice(`Issue auto-closed: #${issue_number}`);
            core.setOutput('closed_issue_number', String(issue_number))
      - name: Job summary
        run: |
          echo "Bot automation completed for $GITHUB_REPOSITORY" >> $GITHUB_STEP_SUMMARY
          echo "See logs for authentication, Pages status, issue verification, and conditional closure." >> $GITHUB_STEP_SUMMARY
